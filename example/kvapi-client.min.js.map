{"version":3,"file":"kvapi-client.min.js","mappings":"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","sources":["webpack://KvapiClient/webpack/universalModuleDefinition","webpack://KvapiClient/./src/Api.ts","webpack://KvapiClient/./src/Encryption.ts","webpack://KvapiClient/./src/GenericApi.ts","webpack://KvapiClient/./src/errors/InvalidParamError.ts","webpack://KvapiClient/./src/errors/ServerError.ts","webpack://KvapiClient/./src/errors/index.ts","webpack://KvapiClient/./src/index.ts","webpack://KvapiClient/./src/specificApis/AppInfoApi.ts","webpack://KvapiClient/./src/specificApis/EntriesApi.ts","webpack://KvapiClient/./src/specificApis/SessionsApi.ts","webpack://KvapiClient/./src/specificApis/UsersApi.ts","webpack://KvapiClient/./src/specificApis/index.ts","webpack://KvapiClient/./src/utils/Deferred.ts","webpack://KvapiClient/./src/utils/index.ts","webpack://KvapiClient/webpack/bootstrap","webpack://KvapiClient/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"KvapiClient\"] = factory();\n\telse\n\t\troot[\"KvapiClient\"] = factory();\n})(self, () => {\nreturn ","import * as Types from \"@wpazderski/kvapi-types\";\nimport { AppInfoApi } from \"./specificApis/AppInfoApi\";\nimport { EntriesApi } from \"./specificApis/EntriesApi\";\nimport { GenericApi, GenericApiOptions, RequestHeaders } from \"./GenericApi\";\nimport { SessionsApi } from \"./specificApis/SessionsApi\";\nimport { UsersApi } from \"./specificApis/UsersApi\";\nimport { Encryption } from \"./Encryption\";\n\ninterface UserPrivateData {\n    encryptionKey: string;\n}\n\nexport interface ApiOptions extends Omit<GenericApiOptions, \"commonHeadersProvider\"> {\n}\n\nexport class Api {\n    \n    private _appInfoApi: AppInfoApi;\n    private _publicEntriesApi: EntriesApi;\n    private _privateEntriesApi: EntriesApi;\n    private _sessionsApi: SessionsApi;\n    private _usersApi: UsersApi;\n    private _userSessionId: Types.data.session.Id | null = null;\n    private _user: Types.data.user.UserWithoutPassword | null = null;\n    private _userPasswordBasedEncryption: Encryption | null = null;\n    protected _genericApi: GenericApi;\n    \n    get appInfo(): AppInfoApi {\n        return this._appInfoApi;\n    }\n    \n    get publicEntries(): EntriesApi {\n        return this._publicEntriesApi;\n    }\n    \n    get privateEntries(): EntriesApi {\n        return this._privateEntriesApi;\n    }\n    \n    get sessions(): SessionsApi {\n        return this._sessionsApi;\n    }\n    \n    get users(): UsersApi {\n        return this._usersApi;\n    }\n    \n    get userSessionId(): Types.data.session.Id | null {\n        return this.parentApi ? this.parentApi.userSessionId : this._userSessionId;\n    }\n    private set userSessionId(sessionId: Types.data.session.Id | null) {\n        if (this.parentApi) {\n            this.parentApi.userSessionId = sessionId;\n        }\n        else {\n            this._userSessionId = sessionId;\n        }\n    }\n    \n    get user(): Types.data.user.UserWithoutPassword | null {\n        return this.parentApi ? this.parentApi.user : this._user;\n    }\n    private set user(userId: Types.data.user.UserWithoutPassword | null) {\n        if (this.parentApi) {\n            this.parentApi.user = userId;\n        }\n        else {\n            this._user = userId;\n        }\n    }\n    \n    get userPasswordBasedEncryption(): Encryption | null {\n        return this.parentApi ? this.parentApi.userPasswordBasedEncryption : this._userPasswordBasedEncryption;\n    }\n    private set userPasswordBasedEncryption(userPasswordBasedEncryption: Encryption | null) {\n        if (this.parentApi) {\n            this.parentApi.userPasswordBasedEncryption = userPasswordBasedEncryption;\n        }\n        else {\n            this._userPasswordBasedEncryption = userPasswordBasedEncryption;\n        }\n    }\n    \n    get genericApi(): GenericApi {\n        return this._genericApi;\n    }\n    \n    constructor(protected baseUrl: string, private options?: Partial<ApiOptions>, private parentApi: Api | null = null) {\n        this._genericApi = new GenericApi(\n            baseUrl,\n            {\n                ...this.options,\n                commonHeadersProvider: () => {\n                    const headers: RequestHeaders = {};\n                    if (this.userSessionId !== null) {\n                        headers[\"kvapi-session-id\"] = this.userSessionId;\n                    }\n                    return headers;\n                },\n            },\n            parentApi ? parentApi.genericApi : null,\n        );\n        this._appInfoApi = new AppInfoApi(this.genericApi);\n        this._publicEntriesApi = new EntriesApi(this.genericApi, \"public\");\n        this._privateEntriesApi = new EntriesApi(this.genericApi, \"private\");\n        this._sessionsApi = new SessionsApi(\n            this.genericApi,\n            {\n                onSessionStarted: (response, userPassword) => this.onSessionStarted(response, userPassword),\n                onSessionTerminated: () => this.onSessionTerminated(),\n            },\n        );\n        this._usersApi = new UsersApi(\n            this.genericApi,\n            {\n                onBeforeUserUpdated: async (userId, request) => this.onBeforeUserUpdated(userId, request),\n                onUserUpdated: async (user, plainPassword) => this.onUserUpdated(user, plainPassword),\n            },\n        );\n    }\n    \n    private async onSessionStarted(createSessionResponse: Types.api.sessions.CreateSessionResponse, userPassword: Types.data.user.PlainPassword): Promise<void> {\n        this.userSessionId = createSessionResponse.id;\n        this.user = createSessionResponse.user;\n        if (!this.genericApi.isE2EEncrypted()) {\n            return;\n        }\n        const passwordBasedKey = await Encryption.generateKeyFromPassword(userPassword);\n        const passwordBasedEncryption = new Encryption(passwordBasedKey);\n        this.userPasswordBasedEncryption = passwordBasedEncryption;\n        let encryptionKey: CryptoKey;\n        if (createSessionResponse.user.privateData) {\n            const privateData: UserPrivateData = JSON.parse(await passwordBasedEncryption.decrypt(createSessionResponse.user.privateData));\n            encryptionKey = await Encryption.importKey(privateData.encryptionKey);\n        }\n        else {\n            encryptionKey = await Encryption.generateRandomKey();\n            const privateData: UserPrivateData = {\n                encryptionKey: await Encryption.exportKey(encryptionKey),\n            };\n            const privateDataStr = await passwordBasedEncryption.encrypt(JSON.stringify(privateData)) as Types.data.user.PrivateData;\n            await this.users.update(createSessionResponse.user.id, { privateData: privateDataStr });\n        }\n        this.genericApi.maybeInitEncryption(encryptionKey);\n    }\n    \n    private async onSessionTerminated(): Promise<void> {\n        this.userSessionId = null;\n        this.user = null;\n        this.userPasswordBasedEncryption = null;\n        this.genericApi.disposeEncryption();\n    }\n    \n    private async onBeforeUserUpdated(userId: Types.data.user.Id, request: Types.api.users.UpdateUserRequest): Promise<void> {\n        if (!this.user) {\n            return;\n        }\n        if (userId !== this.user.id) {\n            return;\n        }\n        if (!this.genericApi.isE2EEncrypted()) {\n            return;\n        }\n        if (!request.password) {\n            return;\n        }\n        \n        // Updating own password with e2ee enabled requires updating privateData\n        const newPassword = request.password;\n        const newPasswordBasedKey = await Encryption.generateKeyFromPassword(newPassword);\n        const oldPasswordBasedEncryption = this.userPasswordBasedEncryption!;\n        const newPasswordBasedEncryption = new Encryption(newPasswordBasedKey);\n        let privateData: UserPrivateData;\n        if (request.privateData) {\n            try {\n                privateData = JSON.parse(await newPasswordBasedEncryption.decrypt(request.privateData));\n            }\n            catch {\n                privateData = JSON.parse(await oldPasswordBasedEncryption.decrypt(request.privateData));\n            }\n        }\n        else {\n            privateData = JSON.parse(await oldPasswordBasedEncryption.decrypt(this.user.privateData!));\n        }\n        const privateDataStr = await newPasswordBasedEncryption.encrypt(JSON.stringify(privateData)) as Types.data.user.PrivateData;\n        request.privateData = privateDataStr;\n    }\n    \n    private async onUserUpdated(user: Types.data.user.UserPublic | Types.data.user.UserWithoutPassword, plainPassword?: Types.data.user.PlainPassword): Promise<void> {\n        if (!this.user) {\n            return;\n        }\n        if (user.id !== this.user.id) {\n            return;\n        }\n        if (this.genericApi.isE2EEncrypted() && plainPassword) {\n            const newPasswordBasedKey = await Encryption.generateKeyFromPassword(plainPassword);\n            const newPasswordBasedEncryption = new Encryption(newPasswordBasedKey);\n            this.userPasswordBasedEncryption = newPasswordBasedEncryption;\n        }\n        this.user = {\n            ...this.user,\n            ...user,\n        };\n    }\n    \n    createBatchedApi(): Api {\n        return new Api(this.baseUrl, { ...this.options, batchMode: true }, this);\n    }\n    \n    executeBatch(): Promise<void> {\n        return this.genericApi.executeBatch();\n    }\n    \n}\n","export interface EncryptedData {\n    data: string;\n    iv: string;\n}\n\nexport class Encryption {\n    \n    static async sha512<T extends string>(text: T): Promise<T> {\n        const arrBuf = await crypto.subtle.digest(\"SHA-512\", new TextEncoder().encode(text));\n        const arr = [...new Uint8Array(arrBuf)];\n        return arr.map(x => x.toString(16).padStart(2, \"0\")).join(\"\") as T;\n    }\n    \n    private static uint8ArrayToString(arr: Uint8Array): string {\n        return [...arr].map(x => String.fromCharCode(x)).join(\"\");\n    }\n    \n    private static stringToUint8Array(str: string): Uint8Array {\n        return Uint8Array.from(str.split(\"\").map(chr => chr.charCodeAt(0)));\n    }\n    \n    private static uint16ArrayToString(arr: Uint16Array): string {\n        return [...arr].map(x => String.fromCharCode(x)).join(\"\");\n    }\n    \n    private static stringToUint16Array(str: string): Uint16Array {\n        return Uint16Array.from(str.split(\"\").map(chr => chr.charCodeAt(0)));\n    }\n    \n    static async exportKey(key: CryptoKey): Promise<string> {\n        const arrBuff = await crypto.subtle.exportKey(\"raw\", key);\n        const str = this.uint8ArrayToString(new Uint8Array(arrBuff));\n        const safeStr = btoa(str);\n        return safeStr;\n    }\n    \n    static async importKey(str: string): Promise<CryptoKey> {\n        const uint8Array = new Uint8Array(atob(str).split(\"\").map(x => x.charCodeAt(0)));\n        const key = await crypto.subtle.importKey(\n            \"raw\",\n            uint8Array,\n            {\n                name: \"AES-GCM\",\n            },\n            true,\n            [ \"encrypt\", \"decrypt\" ]);\n        return key;\n    }\n    \n    static async generateRandomKey(): Promise<CryptoKey> {\n        const key = await crypto.subtle.generateKey(\n            {\n                name: \"AES-GCM\",\n                length: 256,\n            },\n            true,\n            [\"encrypt\", \"decrypt\"]\n        );\n        return key;\n    }\n    \n    static async generateKeyFromPassword(password: string): Promise<CryptoKey> {\n        const passwordData = new TextEncoder().encode(password);\n        const hash = await crypto.subtle.digest(\"SHA-256\", passwordData);\n        const key = await crypto.subtle.importKey(\n            \"raw\",\n            hash,\n            {\n                name: \"AES-GCM\",\n            },\n            true,\n            [ \"encrypt\", \"decrypt\" ]);\n        return key;\n    }\n    \n    \n    \n    \n    \n    constructor(private key: CryptoKey) {\n    }\n    \n    async encrypt(data: string): Promise<string> {\n        const encryptedData = await this.encryptCore(data);\n        return JSON.stringify(encryptedData);\n    }\n    \n    async decrypt(data: string): Promise<string> {\n        const encryptedData: EncryptedData = JSON.parse(data);\n        return this.decryptCore(encryptedData);\n    }\n    \n    private async encryptCore(data: string): Promise<EncryptedData> {\n        const iv = crypto.getRandomValues(new Uint8Array(12));\n        const encryptedData = await crypto.subtle.encrypt(\n            {\n                name: \"AES-GCM\",\n                iv: iv,\n            },\n            this.key,\n            Encryption.stringToUint16Array(data),\n        );\n        return {\n            data: btoa(Encryption.uint8ArrayToString(new Uint8Array(encryptedData))),\n            iv: btoa(Encryption.uint8ArrayToString(iv)),\n        };\n    }\n    \n    private async decryptCore(encryptedData: EncryptedData): Promise<string> {\n        const data = await crypto.subtle.decrypt(\n            {\n                name: \"AES-GCM\",\n                iv: Encryption.stringToUint8Array(atob(encryptedData.iv)),\n            },\n            this.key,\n            Encryption.stringToUint8Array(atob(encryptedData.data)),\n        );\n        return Encryption.uint16ArrayToString(new Uint16Array(data));\n    }\n    \n    \n    \n    \n    \n    \n    async encrypt16(data: string): Promise<string> {\n        const encryptedData = await this.encryptCore16(data);\n        return JSON.stringify(encryptedData);\n    }\n    \n    async decrypt16(data: string): Promise<string> {\n        const encryptedData: EncryptedData = JSON.parse(data);\n        return this.decryptCore16(encryptedData);\n    }\n    \n    private async encryptCore16(data: string): Promise<EncryptedData> {\n        const iv = crypto.getRandomValues(new Uint16Array(6));\n        const encryptedData = await crypto.subtle.encrypt(\n            {\n                name: \"AES-GCM\",\n                iv: iv,\n            },\n            this.key,\n            Encryption.stringToUint16Array(data),\n        );\n        return {\n            data: Encryption.uint16ArrayToString(new Uint16Array(encryptedData)),\n            iv: Encryption.uint16ArrayToString(iv),\n        };\n    }\n    \n    private async decryptCore16(encryptedData: EncryptedData): Promise<string> {\n        const data = await crypto.subtle.decrypt(\n            {\n                name: \"AES-GCM\",\n                iv: Encryption.stringToUint16Array(encryptedData.iv),\n            },\n            this.key,\n            Encryption.stringToUint16Array(encryptedData.data),\n        );\n        return Encryption.uint16ArrayToString(new Uint16Array(data));\n    }\n    \n}\n","import * as Types from \"@wpazderski/kvapi-types\";\nimport { Deferred } from \"./utils/Deferred\";\nimport { ServerError } from \"./errors/ServerError\";\nimport { Encryption } from \"./Encryption\";\n\nexport type RequestHeaders = { [key: string]: string };\n\ninterface BatchedRequestEx extends Types.api.batch.BatchedRequest {\n    deferred: Deferred<any>;\n}\n\nexport interface GenericApiOptions {\n    batchMode: boolean;\n    e2ee: boolean;\n    commonHeadersProvider: () => RequestHeaders;\n    onRequestError: ((error: Error) => void) | null;\n}\n\nexport class GenericApi {\n    \n    private options: GenericApiOptions;\n    private currentBatchedRequestsEx: (BatchedRequestEx | Deferred<BatchedRequestEx | null>)[] = [];\n    private _encryption: Encryption | null = null;\n    \n    private get encryption(): Encryption | null {\n        return this.parentGenericApi ? this.parentGenericApi.encryption : this._encryption;\n    }\n    private set encryption(encryption: Encryption | null) {\n        if (this.parentGenericApi) {\n            this.parentGenericApi.encryption = encryption;\n        }\n        else {\n            this._encryption = encryption;\n        }\n    }\n    \n    constructor(private baseUrl: string, options?: Partial<GenericApiOptions>, private parentGenericApi: GenericApi | null = null) {\n        this.options = {\n            batchMode: false,\n            e2ee: false,\n            commonHeadersProvider: () => ({}),\n            onRequestError: null,\n            ...options,\n        };\n        if (this.baseUrl && !this.baseUrl.endsWith(\"/\")) {\n            this.baseUrl += \"/\";\n        }\n    }\n    \n    isE2EEncrypted(): boolean {\n        return this.options.e2ee;\n    }\n    \n    maybeInitEncryption(encryptionKey: CryptoKey): void {\n        if (!this.options.e2ee || this.encryption) {\n            return;\n        }\n        this.encryption = new Encryption(encryptionKey);\n    }\n    \n    disposeEncryption(): void {\n        this.encryption = null;\n    }\n    \n    async maybeEncrypt<T extends string>(data: T, entryAccess?: Types.data.entry.EntryAccess): Promise<T> {\n        if (!this.shouldUseEncryption(entryAccess)) {\n            return data;\n        }\n        const encrypted = await this.encryption!.encrypt(data);\n        return encrypted as T;\n    }\n    \n    async maybeDecrypt<T extends string>(data: T, entryAccess?: Types.data.entry.EntryAccess): Promise<T> {\n        if (!this.shouldUseEncryption(entryAccess)) {\n            return data;\n        }\n        const decrypted = await this.encryption!.decrypt(data);\n        return decrypted as T;\n    }\n    \n    private shouldUseEncryption(entryAccess?: Types.data.entry.EntryAccess): boolean {\n        if (!this.options.e2ee) {\n            return false;\n        }\n        if (entryAccess === \"public\") {\n            return false;\n        }\n        if (!this.encryption && GenericApi) {\n        }\n        if (!this.encryption) {\n            throw new Error(\"Encryption not initialized\");\n        }\n        return true;\n    }\n    \n    get<TResponse>(url: string, canBeBatched: boolean = true): Promise<TResponse> {\n        return this.request(\"get\", url, undefined, canBeBatched);\n    }\n    \n    post<TRequest, TResponse>(url: string, data: TRequest, canBeBatched: boolean = true): Promise<TResponse> {\n        return this.request(\"post\", url, data, canBeBatched);\n    }\n    \n    patch<TRequest, TResponse>(url: string, data: TRequest, canBeBatched: boolean = true): Promise<TResponse> {\n        return this.request(\"patch\", url, data, canBeBatched);\n    }\n    \n    put<TRequest, TResponse>(url: string, data: TRequest, canBeBatched: boolean = true): Promise<TResponse> {\n        return this.request(\"put\", url, data, canBeBatched);\n    }\n    \n    delete<TRequest, TResponse>(url: string, data: TRequest, canBeBatched: boolean = true): Promise<TResponse> {\n        return this.request(\"delete\", url, data, canBeBatched);\n    }\n    \n    request<TRequest, TResponse>(method: Types.api.request.Method, url: string, data?: TRequest, canBeBatched: boolean = true): Promise<TResponse> {\n        if (this.options.batchMode && canBeBatched) {\n            const deferred = new Deferred<TResponse>();\n            this.currentBatchedRequestsEx.push({ method, url, data, deferred });\n            return deferred.getPromise();\n        }\n        else {\n            return this.requestCore(method, url, data);\n        }\n    }\n    \n    private async requestCore<TRequest, TResponse>(method: Types.api.request.Method, url: string, data?: TRequest): Promise<TResponse> {\n        const headers: RequestHeaders = {\n            ...this.options.commonHeadersProvider(),\n            \"Content-Type\": \"application/json\",\n        };\n        try {\n            const response = await fetch(this.getFullUrl(url), {\n                method: method.toUpperCase(),\n                headers,\n                body: data !== undefined ? JSON.stringify(data) : null,\n            });\n            if (response.status === 200) {\n                return await response.json();\n            }\n            else {\n                let details: any;\n                try {\n                    details = await response.json();\n                }\n                catch {}\n                throw new ServerError(response.status, response.statusText, details);\n            }\n        }\n        catch (error) {\n            if (error instanceof Error && this.options.onRequestError) {\n                try {\n                    this.options.onRequestError(error);\n                }\n                catch (callbackError) {\n                    console.error(callbackError);\n                }\n            }\n            throw error;\n        }\n    }\n    \n    private getFullUrl(url: string): string {\n        if (url.startsWith(\"/\")) {\n            url = url.substring(1);\n        }\n        return this.baseUrl + url;\n    }\n    \n    async executeBatch(): Promise<void> {\n        if (this.currentBatchedRequestsEx.length === 0) {\n            return;\n        }\n        \n        const batchedRequestsEx = this.currentBatchedRequestsEx;\n        this.currentBatchedRequestsEx = [];\n        const batchedRequestsExResolved: BatchedRequestEx[] = [];\n        for (const batchedRequestEx of batchedRequestsEx) {\n            if (batchedRequestEx instanceof Deferred) {\n                const req = await batchedRequestEx.getPromise();\n                if (req !== null) {\n                    batchedRequestsExResolved.push(req);\n                }\n            }\n            else {\n                batchedRequestsExResolved.push(batchedRequestEx);\n            }\n        }\n        const batchedRequests = batchedRequestsExResolved.map(request => (<Types.api.batch.BatchedRequest>{\n            method: request.method,\n            url: request.url,\n            data: request.data,\n        }));\n        \n        const data: Types.api.batch.Request = {\n            batchedRequests,\n        };\n        const result = await this.requestCore(\"post\", \"batch\", data) as Types.api.batch.Response;\n        for (let i = 0; i < batchedRequests.length; ++i) {\n            try {\n                const request = batchedRequestsExResolved[i]!;\n                const response = result.batchedResponses[i]!;\n                if (response.statusCode === 200) {\n                    request.deferred.resolve(JSON.parse(response.response));\n                }\n                else {\n                    let details: any;\n                    try {\n                        details = JSON.parse(response.response);\n                    }\n                    catch {}\n                    request.deferred.reject(new ServerError(response.statusCode, response.statusText, details));\n                }\n            }\n            catch (err) {\n                console.error(err);\n            }\n        }\n    }\n    \n    async buildRequestAsynchronously<T>(builder: () => Promise<() => Promise<T>>): Promise<T> {\n        if (!this.options.batchMode) {\n            return (await builder())();\n        }\n        const deferred = new Deferred<BatchedRequestEx | null>();\n        this.currentBatchedRequestsEx.push(deferred);\n        try {\n            const requestScheduler = await builder();\n            const requestPromise = requestScheduler();\n            const idx = this.currentBatchedRequestsEx.findIndex(req => req && !(req instanceof Deferred) && req.deferred.getPromise() === requestPromise);\n            if (idx < 0) {\n                throw new Error(\"buildRequestAsynchronously: no batched request\");\n            }\n            const batchedRequest = this.currentBatchedRequestsEx[idx];\n            if (!batchedRequest || batchedRequest instanceof Deferred) {\n                throw new Error(\"buildRequestAsynchronously: unexpected batched request object\");\n            }\n            this.currentBatchedRequestsEx.splice(idx, 1);\n            deferred.resolve(batchedRequest);\n            return requestPromise;\n        }\n        catch (err) {\n            deferred.resolve(null);\n            throw err;\n        }\n    }\n    \n    getCurrentBatchSize(): number {\n        return this.currentBatchedRequestsEx.length;\n    }\n    \n}\n","export class InvalidParamError extends Error {\n    \n    constructor(paramName: string) {\n        super(`Invalid param: ${paramName}`);\n    }\n    \n}\n","export class ServerError extends Error {\n    \n    static getErrorMessage(statusCode: number, statusText: string, details: any): string {\n        let msg = `Server error: ${statusCode} ${statusText}`;\n        if (details) {\n            msg += \" (\";\n            if (typeof(details) === \"object\") {\n                msg += JSON.stringify(details);\n            }\n            else {\n                msg += details;\n            }\n            msg += \")\";\n        }\n        return msg;\n    }\n    \n    constructor(protected statusCode: number, protected statusText: string, protected details: any) {\n        super(ServerError.getErrorMessage(statusCode, statusText, details));\n    }\n    \n    getStatusCode(): number {\n        return this.statusCode;\n    }\n    \n    getStatusMessage(): string {\n        return this.statusText;\n    }\n    \n    getDetails(): any {\n        return this.details;\n    }\n    \n}\n","export * from \"./InvalidParamError\";\nexport * from \"./ServerError\";\n","export * as errors from \"./errors\";\nexport * as specificApis from \"./specificApis\";\nexport * as utils from \"./utils\";\nexport * from \"./Api\";\nexport * from \"./Encryption\";\nexport * from \"./GenericApi\";\n","import * as Types from \"@wpazderski/kvapi-types\";\nimport { GenericApi } from \"../GenericApi\";\n\nexport class AppInfoApi {\n    \n    constructor(private genericApi: GenericApi) {\n    }\n    \n    async get(): Promise<Types.api.appInfo.GetAppInfoResponse> {\n        const response: Types.api.appInfo.GetAppInfoResponse = await this.genericApi.get(\"app-info\");\n        return response;\n    }\n    \n}\n","import * as Types from \"@wpazderski/kvapi-types\";\nimport { InvalidParamError } from \"../errors\";\nimport { GenericApi } from \"../GenericApi\";\n\nexport class EntriesApi {\n    \n    constructor(private genericApi: GenericApi, private entryAccess: Types.data.entry.EntryAccess) {\n    }\n    \n    async getAll(): Promise<Types.data.entry.KeyValueMap> {\n        const response: Types.api.entries.GetEntriesResponse = await this.genericApi.get(`${this.entryAccess}-entries`);\n        const entries: Types.data.entry.KeyValueMap = {};\n        for (const key in response.entries) {\n            let value = (response.entries as any)[key];\n            value = await this.genericApi.maybeDecrypt(value, this.entryAccess);\n            (entries as any)[key] = value;\n        }\n        return entries;\n    }\n    \n    async get(key: Types.data.entry.Key): Promise<Types.data.entry.Value> {\n        key = key.trim() as Types.data.entry.Key;\n        if (!key) {\n            throw new InvalidParamError(\"key\");\n        }\n        const response: Types.api.entries.GetEntryResponse = await this.genericApi.get(`${this.entryAccess}-entries/${key}`);\n        return this.genericApi.maybeDecrypt(response.value, this.entryAccess);\n    }\n    \n    async set(key: Types.data.entry.Key, value: Types.data.entry.Value): Promise<void> {\n        key = key.trim() as Types.data.entry.Key;\n        if (!key) {\n            throw new InvalidParamError(\"key\");\n        }\n        await this.genericApi.buildRequestAsynchronously(async () => {\n            value = await this.genericApi.maybeEncrypt(value, this.entryAccess);\n            const request: Types.api.entries.CreateOrUpdateEntryRequest = { value };\n            return () => this.genericApi.put(`${this.entryAccess}-entries/${key}`, request);\n        });\n    }\n    \n    async delete(key: Types.data.entry.Key): Promise<void> {\n        key = key.trim() as Types.data.entry.Key;\n        if (!key) {\n            throw new InvalidParamError(\"key\");\n        }\n        await this.genericApi.delete(`${this.entryAccess}-entries/${key}`, {});\n    }\n    \n}\n","import * as Types from \"@wpazderski/kvapi-types\";\nimport { Encryption } from \"../Encryption\";\nimport { GenericApi } from \"../GenericApi\";\n\nexport interface SessionApiOptions {\n    onSessionStarted: (response: Types.api.sessions.CreateSessionResponse, userPassword: Types.data.user.PlainPassword) => Promise<void>;\n    onSessionTerminated: () => Promise<void>;\n}\n\nexport class SessionsApi {\n    \n    constructor(private genericApi: GenericApi, private options: SessionApiOptions) {\n    }\n    \n    async create(userLogin: Types.data.user.Login, userPassword: Types.data.user.PlainPassword): Promise<Types.api.sessions.CreateSessionResponse> {\n        const plainUserPassword = userPassword;\n        userPassword = await Encryption.sha512(userPassword);\n        const request: Types.api.sessions.CreateSessionRequest = { userLogin, userPassword };\n        const response: Types.api.sessions.CreateSessionResponse = await this.genericApi.post(\"sessions\", request, false);\n        if (response && response.id) {\n            await this.options.onSessionStarted(response, plainUserPassword);\n        }\n        return response;\n    }\n    \n    async update(): Promise<void> {\n        await this.genericApi.patch<Types.api.sessions.UpdateSessionRequest, Types.api.sessions.UpdateSessionResponse>(\"sessions\", {}, false);\n    }\n    \n    async delete(): Promise<void> {\n        await this.genericApi.delete<Types.api.sessions.DeleteSessionRequest, Types.api.sessions.DeleteSessionResponse>(\"sessions\", {}, false);\n        await this.options.onSessionTerminated();\n    }\n    \n}\n","import * as Types from \"@wpazderski/kvapi-types\";\nimport { Encryption } from \"../Encryption\";\nimport { InvalidParamError } from \"../errors\";\nimport { GenericApi } from \"../GenericApi\";\n\nexport interface UsersApiOptions {\n    onBeforeUserUpdated: (userId: Types.data.user.Id, request: Types.api.users.UpdateUserRequest) => Promise<void>;\n    onUserUpdated: (user: Types.data.user.UserPublic | Types.data.user.UserWithoutPassword, plainPassword?: Types.data.user.PlainPassword) => Promise<void>;\n}\n\nexport class UsersApi {\n    \n    constructor(private genericApi: GenericApi, private options: UsersApiOptions) {\n    }\n    \n    async getAll(): Promise<Types.data.user.UsersPublic> {\n        const result: Types.api.users.GetUsersResponse = await this.genericApi.get(\"users\");\n        return result.users;\n    }\n    \n    async get(userId: Types.data.user.Id): Promise<Types.data.user.UserPublic | Types.data.user.UserWithoutPassword> {\n        userId = userId.trim() as Types.data.user.Id;\n        if (!userId) {\n            throw new InvalidParamError(\"userId\");\n        }\n        const result: Types.api.users.GetUserResponse = await this.genericApi.get(`users/${userId}`);\n        return result.user;\n    }\n    \n    async create(request: Types.api.users.CreateUserRequest): Promise<Types.data.user.UserPublic> {\n        request = {\n            login: request.login,\n            password: await Encryption.sha512(request.password),\n            role: request.role,\n        };\n        const result: Types.api.users.CreateUserResponse = await this.genericApi.post(\"users\", request);\n        return result.user;\n    }\n    \n    async update(userId: Types.data.user.Id, request: Types.api.users.UpdateUserRequest): Promise<Types.data.user.UserPublic | Types.data.user.UserWithoutPassword> {\n        userId = userId.trim() as Types.data.user.Id;\n        if (!userId) {\n            throw new InvalidParamError(\"userId\");\n        }\n        const plainPassword = request.password;\n        const result: Types.api.users.UpdateUserResponse = await this.genericApi.buildRequestAsynchronously(async () => {\n            request = { ...request };\n            await this.options.onBeforeUserUpdated(userId, request);\n            if (request.password) {\n                request.password = await Encryption.sha512(request.password);\n            }\n            return () => this.genericApi.patch(`users/${userId}`, request);\n        });\n        if (\"privateData\" in result.user) {\n            this.options.onUserUpdated(\n                {\n                    id: userId,\n                    login: result.user.login,\n                    role: result.user.role,\n                    lastPasswordUpdateTimestamp: result.user.lastPasswordUpdateTimestamp,\n                    privateData: result.user.privateData,\n                },\n                plainPassword,\n            );\n        }\n        else {\n            this.options.onUserUpdated({\n                id: userId,\n                login: result.user.login,\n                role: result.user.role,\n            });\n        }\n        return result.user;\n    }\n    \n    async delete(userId: Types.data.user.Id): Promise<void> {\n        userId = userId.trim() as Types.data.user.Id;\n        if (!userId) {\n            throw new InvalidParamError(\"userId\");\n        }\n        await this.genericApi.delete<Types.api.users.DeleteUserRequest, Types.api.users.DeleteUserResponse>(`users/${userId}`, {});\n    }\n    \n}\n","export * from \"./AppInfoApi\";\nexport * from \"./EntriesApi\";\nexport * from \"./SessionsApi\";\nexport * from \"./UsersApi\";\n","export class Deferred<T> {\n    \n    private promise: Promise<T>;\n    // @ts-ignore\n    resolve: (value: T) => void;\n    // @ts-ignore\n    reject: (reason: any) => void;\n    \n    constructor() {\n        this.promise = new Promise<T>((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    \n    getPromise(): Promise<T> {\n        return this.promise;\n    }\n    \n}\n","export * from \"./Deferred\";\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"names":["root","factory","exports","module","define","amd","self","Api","constructor","baseUrl","options","parentApi","_userSessionId","_user","_userPasswordBasedEncryption","this","_genericApi","GenericApi","commonHeadersProvider","headers","userSessionId","genericApi","_appInfoApi","AppInfoApi","_publicEntriesApi","EntriesApi","_privateEntriesApi","_sessionsApi","SessionsApi","onSessionStarted","response","userPassword","onSessionTerminated","_usersApi","UsersApi","onBeforeUserUpdated","async","userId","request","onUserUpdated","user","plainPassword","appInfo","publicEntries","privateEntries","sessions","users","sessionId","userPasswordBasedEncryption","createSessionResponse","id","isE2EEncrypted","passwordBasedKey","Encryption","generateKeyFromPassword","passwordBasedEncryption","encryptionKey","privateData","JSON","parse","decrypt","importKey","generateRandomKey","exportKey","privateDataStr","encrypt","stringify","update","maybeInitEncryption","disposeEncryption","password","newPassword","newPasswordBasedKey","oldPasswordBasedEncryption","newPasswordBasedEncryption","createBatchedApi","batchMode","executeBatch","key","static","text","arrBuf","crypto","subtle","digest","TextEncoder","encode","Uint8Array","map","x","toString","padStart","join","arr","String","fromCharCode","str","from","split","chr","charCodeAt","Uint16Array","arrBuff","uint8ArrayToString","btoa","uint8Array","atob","name","generateKey","length","passwordData","hash","data","encryptedData","encryptCore","decryptCore","iv","getRandomValues","stringToUint16Array","stringToUint8Array","uint16ArrayToString","encryptCore16","decryptCore16","parentGenericApi","currentBatchedRequestsEx","_encryption","e2ee","onRequestError","endsWith","encryption","entryAccess","shouldUseEncryption","Error","get","url","canBeBatched","undefined","post","patch","put","delete","method","deferred","Deferred","push","getPromise","requestCore","fetch","getFullUrl","toUpperCase","body","status","json","details","ServerError","statusText","error","callbackError","console","startsWith","substring","batchedRequestsEx","batchedRequestsExResolved","batchedRequestEx","req","batchedRequests","result","i","batchedResponses","statusCode","resolve","reject","err","builder","requestPromise","idx","findIndex","batchedRequest","splice","getCurrentBatchSize","InvalidParamError","paramName","super","getErrorMessage","msg","getStatusCode","getStatusMessage","getDetails","entries","value","maybeDecrypt","trim","buildRequestAsynchronously","maybeEncrypt","userLogin","plainUserPassword","sha512","login","role","lastPasswordUpdateTimestamp","promise","Promise","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}