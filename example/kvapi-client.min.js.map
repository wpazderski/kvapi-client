{"version":3,"file":"kvapi-client.min.js","mappings":"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","sources":["webpack://KvapiClient/webpack/universalModuleDefinition","webpack://KvapiClient/./src/Api.ts","webpack://KvapiClient/./src/Encryption.ts","webpack://KvapiClient/./src/GenericApi.ts","webpack://KvapiClient/./src/errors/InvalidParamError.ts","webpack://KvapiClient/./src/errors/ServerError.ts","webpack://KvapiClient/./src/errors/index.ts","webpack://KvapiClient/./src/index.ts","webpack://KvapiClient/./src/specificApis/AppInfoApi.ts","webpack://KvapiClient/./src/specificApis/EntriesApi.ts","webpack://KvapiClient/./src/specificApis/SessionsApi.ts","webpack://KvapiClient/./src/specificApis/UsersApi.ts","webpack://KvapiClient/./src/specificApis/index.ts","webpack://KvapiClient/./src/utils/Deferred.ts","webpack://KvapiClient/./src/utils/index.ts","webpack://KvapiClient/webpack/bootstrap","webpack://KvapiClient/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"KvapiClient\"] = factory();\n\telse\n\t\troot[\"KvapiClient\"] = factory();\n})(self, () => {\nreturn ","import * as Types from \"@wpazderski/kvapi-types\";\nimport { AppInfoApi } from \"./specificApis/AppInfoApi\";\nimport { EntriesApi } from \"./specificApis/EntriesApi\";\nimport { GenericApi, GenericApiOptions, RequestHeaders } from \"./GenericApi\";\nimport { SessionsApi } from \"./specificApis/SessionsApi\";\nimport { UsersApi } from \"./specificApis/UsersApi\";\nimport { Encryption } from \"./Encryption\";\n\ninterface UserPrivateData {\n    encryptionKey: string;\n}\n\nexport interface ApiOptions extends Omit<GenericApiOptions, \"commonHeadersProvider\"> {\n}\n\nexport class Api {\n    \n    private _appInfoApi: AppInfoApi;\n    private _publicEntriesApi: EntriesApi;\n    private _privateEntriesApi: EntriesApi;\n    private _sessionsApi: SessionsApi;\n    private _usersApi: UsersApi;\n    private _userSessionId: Types.data.session.Id | null = null;\n    private _user: Types.data.user.UserWithoutPassword | null = null;\n    private _userPasswordBasedEncryption: Encryption | null = null;\n    protected _genericApi: GenericApi;\n    \n    get appInfo(): AppInfoApi {\n        return this._appInfoApi;\n    }\n    \n    get publicEntries(): EntriesApi {\n        return this._publicEntriesApi;\n    }\n    \n    get privateEntries(): EntriesApi {\n        return this._privateEntriesApi;\n    }\n    \n    get sessions(): SessionsApi {\n        return this._sessionsApi;\n    }\n    \n    get users(): UsersApi {\n        return this._usersApi;\n    }\n    \n    get userSessionId(): Types.data.session.Id | null {\n        return this.parentApi ? this.parentApi.userSessionId : this._userSessionId;\n    }\n    private set userSessionId(sessionId: Types.data.session.Id | null) {\n        if (this.parentApi) {\n            this.parentApi.userSessionId = sessionId;\n        }\n        else {\n            this._userSessionId = sessionId;\n        }\n    }\n    \n    get user(): Types.data.user.UserWithoutPassword | null {\n        return this.parentApi ? this.parentApi.user : this._user;\n    }\n    private set user(userId: Types.data.user.UserWithoutPassword | null) {\n        if (this.parentApi) {\n            this.parentApi.user = userId;\n        }\n        else {\n            this._user = userId;\n        }\n    }\n    \n    get userPasswordBasedEncryption(): Encryption | null {\n        return this.parentApi ? this.parentApi.userPasswordBasedEncryption : this._userPasswordBasedEncryption;\n    }\n    private set userPasswordBasedEncryption(userPasswordBasedEncryption: Encryption | null) {\n        if (this.parentApi) {\n            this.parentApi.userPasswordBasedEncryption = userPasswordBasedEncryption;\n        }\n        else {\n            this._userPasswordBasedEncryption = userPasswordBasedEncryption;\n        }\n    }\n    \n    get genericApi(): GenericApi {\n        return this._genericApi;\n    }\n    \n    constructor(protected baseUrl: string, private options?: Partial<ApiOptions>, private parentApi: Api | null = null) {\n        this._genericApi = new GenericApi(\n            baseUrl,\n            {\n                ...this.options,\n                commonHeadersProvider: () => {\n                    const headers: RequestHeaders = {};\n                    if (this.userSessionId !== null) {\n                        headers[\"kvapi-session-id\"] = this.userSessionId;\n                    }\n                    return headers;\n                },\n            },\n            parentApi ? parentApi.genericApi : null,\n        );\n        this._appInfoApi = new AppInfoApi(this.genericApi);\n        this._publicEntriesApi = new EntriesApi(this.genericApi, \"public\");\n        this._privateEntriesApi = new EntriesApi(this.genericApi, \"private\");\n        this._sessionsApi = new SessionsApi(\n            this.genericApi,\n            {\n                onSessionStarted: (response, userPassword) => this.onSessionStarted(response, userPassword),\n                onSessionTerminated: () => this.onSessionTerminated(),\n            },\n        );\n        this._usersApi = new UsersApi(\n            this.genericApi,\n            {\n                onBeforeUserUpdated: async (userId, request) => this.onBeforeUserUpdated(userId, request),\n                onUserUpdated: async user => this.onUserUpdated(user),\n            },\n        );\n    }\n    \n    private async onSessionStarted(createSessionResponse: Types.api.sessions.CreateSessionResponse, userPassword: Types.data.user.PlainPassword): Promise<void> {\n        this.userSessionId = createSessionResponse.id;\n        this.user = createSessionResponse.user;\n        if (!this.genericApi.isE2EEncrypted()) {\n            return;\n        }\n        const passwordBasedKey = await Encryption.generateKeyFromPassword(userPassword);\n        const passwordBasedEncryption = new Encryption(passwordBasedKey);\n        this.userPasswordBasedEncryption = passwordBasedEncryption;\n        let encryptionKey: CryptoKey;\n        if (createSessionResponse.user.privateData) {\n            const privateData: UserPrivateData = JSON.parse(await passwordBasedEncryption.decrypt(createSessionResponse.user.privateData));\n            encryptionKey = await Encryption.importKey(privateData.encryptionKey);\n        }\n        else {\n            encryptionKey = await Encryption.generateRandomKey();\n            const privateData: UserPrivateData = {\n                encryptionKey: await Encryption.exportKey(encryptionKey),\n            };\n            const privateDataStr = await passwordBasedEncryption.encrypt(JSON.stringify(privateData)) as Types.data.user.PrivateData;\n            await this.users.update(createSessionResponse.user.id, { privateData: privateDataStr });\n        }\n        this.genericApi.maybeInitEncryption(encryptionKey);\n    }\n    \n    private async onSessionTerminated(): Promise<void> {\n        this.userSessionId = null;\n        this.user = null;\n        this.userPasswordBasedEncryption = null;\n        this.genericApi.disposeEncryption();\n    }\n    \n    private async onUserUpdated(user: Types.data.user.UserPublic | Types.data.user.UserWithoutPassword): Promise<void> {\n        if (!this.user) {\n            return;\n        }\n        if (user.id !== this.user.id) {\n            return;\n        }\n        this.user = {\n            ...this.user,\n            ...user,\n        };\n    }\n    \n    private async onBeforeUserUpdated(userId: Types.data.user.Id, request: Types.api.users.UpdateUserRequest): Promise<void> {\n        if (!this.user) {\n            return;\n        }\n        if (userId !== this.user.id) {\n            return;\n        }\n        if (!this.genericApi.isE2EEncrypted()) {\n            return;\n        }\n        if (!request.password) {\n            return;\n        }\n        \n        // Updating own password with e2ee enabled requires updating privateData\n        const newPassword = request.password;\n        const newPasswordBasedKey = await Encryption.generateKeyFromPassword(newPassword);\n        const oldPasswordBasedEncryption = this.userPasswordBasedEncryption!;\n        const newPasswordBasedEncryption = new Encryption(newPasswordBasedKey);\n        let privateData: UserPrivateData;\n        if (request.privateData) {\n            try {\n                privateData = JSON.parse(await newPasswordBasedEncryption.decrypt(request.privateData));\n            }\n            catch {\n                privateData = JSON.parse(await oldPasswordBasedEncryption.decrypt(request.privateData));\n            }\n        }\n        else {\n            privateData = JSON.parse(await oldPasswordBasedEncryption.decrypt(this.user.privateData!));\n        }\n        const privateDataStr = await newPasswordBasedEncryption.encrypt(JSON.stringify(privateData)) as Types.data.user.PrivateData;\n        this.userPasswordBasedEncryption = newPasswordBasedEncryption;\n        request.privateData = privateDataStr;\n    }\n    \n    createBatchedApi(): Api {\n        return new Api(this.baseUrl, { ...this.options, batchMode: true }, this);\n    }\n    \n    executeBatch(): Promise<void> {\n        return this.genericApi.executeBatch();\n    }\n    \n}\n","export interface EncryptedData {\n    data: string;\n    iv: string;\n}\n\nexport class Encryption {\n    \n    static async sha512<T extends string>(text: T): Promise<T> {\n        const arrBuf = await crypto.subtle.digest(\"SHA-512\", new TextEncoder().encode(text));\n        const arr = [...new Uint8Array(arrBuf)];\n        return arr.map(x => x.toString(16).padStart(2, \"0\")).join(\"\") as T;\n    }\n    \n    private static uint8ArrayToString(arr: Uint8Array): string {\n        return [...arr].map(x => String.fromCharCode(x)).join(\"\");\n    }\n    \n    private static stringToUint8Array(str: string): Uint8Array {\n        return Uint8Array.from(str.split(\"\").map(chr => chr.charCodeAt(0)));\n    }\n    \n    private static uint16ArrayToString(arr: Uint16Array): string {\n        return [...arr].map(x => String.fromCharCode(x)).join(\"\");\n    }\n    \n    private static stringToUint16Array(str: string): Uint16Array {\n        return Uint16Array.from(str.split(\"\").map(chr => chr.charCodeAt(0)));\n    }\n    \n    static async exportKey(key: CryptoKey): Promise<string> {\n        const arrBuff = await crypto.subtle.exportKey(\"raw\", key);\n        const str = this.uint8ArrayToString(new Uint8Array(arrBuff));\n        const safeStr = btoa(str);\n        return safeStr;\n    }\n    \n    static async importKey(str: string): Promise<CryptoKey> {\n        const uint8Array = new Uint8Array(atob(str).split(\"\").map(x => x.charCodeAt(0)));\n        const key = await crypto.subtle.importKey(\n            \"raw\",\n            uint8Array,\n            {\n                name: \"AES-GCM\",\n            },\n            true,\n            [ \"encrypt\", \"decrypt\" ]);\n        return key;\n    }\n    \n    static async generateRandomKey(): Promise<CryptoKey> {\n        const key = await crypto.subtle.generateKey(\n            {\n                name: \"AES-GCM\",\n                length: 256,\n            },\n            true,\n            [\"encrypt\", \"decrypt\"]\n        );\n        return key;\n    }\n    \n    static async generateKeyFromPassword(password: string): Promise<CryptoKey> {\n        const passwordData = new TextEncoder().encode(password);\n        const hash = await crypto.subtle.digest(\"SHA-256\", passwordData);\n        const key = await crypto.subtle.importKey(\n            \"raw\",\n            hash,\n            {\n                name: \"AES-GCM\",\n            },\n            true,\n            [ \"encrypt\", \"decrypt\" ]);\n        return key;\n    }\n    \n    \n    \n    \n    \n    constructor(private key: CryptoKey) {\n    }\n    \n    async encrypt(data: string): Promise<string> {\n        const encryptedData = await this.encryptCore(data);\n        return JSON.stringify(encryptedData);\n    }\n    \n    async decrypt(data: string): Promise<string> {\n        const encryptedData: EncryptedData = JSON.parse(data);\n        return this.decryptCore(encryptedData);\n    }\n    \n    private async encryptCore(data: string): Promise<EncryptedData> {\n        const iv = crypto.getRandomValues(new Uint8Array(12));\n        const encryptedData = await crypto.subtle.encrypt(\n            {\n                name: \"AES-GCM\",\n                iv: iv,\n            },\n            this.key,\n            Encryption.stringToUint16Array(data),\n        );\n        return {\n            data: btoa(Encryption.uint8ArrayToString(new Uint8Array(encryptedData))),\n            iv: btoa(Encryption.uint8ArrayToString(iv)),\n        };\n    }\n    \n    private async decryptCore(encryptedData: EncryptedData): Promise<string> {\n        const data = await crypto.subtle.decrypt(\n            {\n                name: \"AES-GCM\",\n                iv: Encryption.stringToUint8Array(atob(encryptedData.iv)),\n            },\n            this.key,\n            Encryption.stringToUint8Array(atob(encryptedData.data)),\n        );\n        return Encryption.uint16ArrayToString(new Uint16Array(data));\n    }\n    \n    \n    \n    \n    \n    \n    async encrypt16(data: string): Promise<string> {\n        const encryptedData = await this.encryptCore16(data);\n        return JSON.stringify(encryptedData);\n    }\n    \n    async decrypt16(data: string): Promise<string> {\n        const encryptedData: EncryptedData = JSON.parse(data);\n        return this.decryptCore16(encryptedData);\n    }\n    \n    private async encryptCore16(data: string): Promise<EncryptedData> {\n        const iv = crypto.getRandomValues(new Uint16Array(6));\n        const encryptedData = await crypto.subtle.encrypt(\n            {\n                name: \"AES-GCM\",\n                iv: iv,\n            },\n            this.key,\n            Encryption.stringToUint16Array(data),\n        );\n        return {\n            data: Encryption.uint16ArrayToString(new Uint16Array(encryptedData)),\n            iv: Encryption.uint16ArrayToString(iv),\n        };\n    }\n    \n    private async decryptCore16(encryptedData: EncryptedData): Promise<string> {\n        const data = await crypto.subtle.decrypt(\n            {\n                name: \"AES-GCM\",\n                iv: Encryption.stringToUint16Array(encryptedData.iv),\n            },\n            this.key,\n            Encryption.stringToUint16Array(encryptedData.data),\n        );\n        return Encryption.uint16ArrayToString(new Uint16Array(data));\n    }\n    \n}\n","import * as Types from \"@wpazderski/kvapi-types\";\nimport { Deferred } from \"./utils/Deferred\";\nimport { ServerError } from \"./errors/ServerError\";\nimport { Encryption } from \"./Encryption\";\n\nexport type RequestHeaders = { [key: string]: string };\n\ninterface BatchedRequestEx extends Types.api.batch.BatchedRequest {\n    deferred: Deferred<any>;\n}\n\nexport interface GenericApiOptions {\n    batchMode: boolean;\n    e2ee: boolean;\n    commonHeadersProvider: () => RequestHeaders;\n}\n\nexport class GenericApi {\n    \n    private options: GenericApiOptions;\n    private currentBatchedRequestsEx: (BatchedRequestEx | Deferred<BatchedRequestEx | null>)[] = [];\n    private _encryption: Encryption | null = null;\n    \n    private get encryption(): Encryption | null {\n        return this.parentGenericApi ? this.parentGenericApi.encryption : this._encryption;\n    }\n    private set encryption(encryption: Encryption | null) {\n        if (this.parentGenericApi) {\n            this.parentGenericApi.encryption = encryption;\n        }\n        else {\n            this._encryption = encryption;\n        }\n    }\n    \n    constructor(private baseUrl: string, options?: Partial<GenericApiOptions>, private parentGenericApi: GenericApi | null = null) {\n        this.options = {\n            batchMode: false,\n            e2ee: false,\n            commonHeadersProvider: () => ({}),\n            ...options,\n        };\n        if (this.baseUrl && !this.baseUrl.endsWith(\"/\")) {\n            this.baseUrl += \"/\";\n        }\n    }\n    \n    isE2EEncrypted(): boolean {\n        return this.options.e2ee;\n    }\n    \n    maybeInitEncryption(encryptionKey: CryptoKey): void {\n        if (!this.options.e2ee || this.encryption) {\n            return;\n        }\n        this.encryption = new Encryption(encryptionKey);\n    }\n    \n    disposeEncryption(): void {\n        this.encryption = null;\n    }\n    \n    async maybeEncrypt<T extends string>(data: T, entryAccess?: Types.data.entry.EntryAccess): Promise<T> {\n        if (!this.shouldUseEncryption(entryAccess)) {\n            return data;\n        }\n        const encrypted = await this.encryption!.encrypt(data);\n        return encrypted as T;\n    }\n    \n    async maybeDecrypt<T extends string>(data: T, entryAccess?: Types.data.entry.EntryAccess): Promise<T> {\n        if (!this.shouldUseEncryption(entryAccess)) {\n            return data;\n        }\n        const decrypted = await this.encryption!.decrypt(data);\n        return decrypted as T;\n    }\n    \n    private shouldUseEncryption(entryAccess?: Types.data.entry.EntryAccess): boolean {\n        if (!this.options.e2ee) {\n            return false;\n        }\n        if (entryAccess === \"public\") {\n            return false;\n        }\n        if (!this.encryption && GenericApi) {\n        }\n        if (!this.encryption) {\n            throw new Error(\"Encryption not initialized\");\n        }\n        return true;\n    }\n    \n    get<TResponse>(url: string, canBeBatched: boolean = true): Promise<TResponse> {\n        return this.request(\"get\", url, undefined, canBeBatched);\n    }\n    \n    post<TRequest, TResponse>(url: string, data: TRequest, canBeBatched: boolean = true): Promise<TResponse> {\n        return this.request(\"post\", url, data, canBeBatched);\n    }\n    \n    patch<TRequest, TResponse>(url: string, data: TRequest, canBeBatched: boolean = true): Promise<TResponse> {\n        return this.request(\"patch\", url, data, canBeBatched);\n    }\n    \n    put<TRequest, TResponse>(url: string, data: TRequest, canBeBatched: boolean = true): Promise<TResponse> {\n        return this.request(\"put\", url, data, canBeBatched);\n    }\n    \n    delete<TRequest, TResponse>(url: string, data: TRequest, canBeBatched: boolean = true): Promise<TResponse> {\n        return this.request(\"delete\", url, data, canBeBatched);\n    }\n    \n    request<TRequest, TResponse>(method: Types.api.request.Method, url: string, data?: TRequest, canBeBatched: boolean = true): Promise<TResponse> {\n        if (this.options.batchMode && canBeBatched) {\n            const deferred = new Deferred<TResponse>();\n            this.currentBatchedRequestsEx.push({ method, url, data, deferred });\n            return deferred.getPromise();\n        }\n        else {\n            return this.requestCore(method, url, data);\n        }\n    }\n    \n    private async requestCore<TRequest, TResponse>(method: Types.api.request.Method, url: string, data?: TRequest): Promise<TResponse> {\n        const headers: RequestHeaders = {\n            ...this.options.commonHeadersProvider(),\n            \"Content-Type\": \"application/json\",\n        };\n        const response = await fetch(this.getFullUrl(url), {\n            method: method.toUpperCase(),\n            headers,\n            body: data !== undefined ? JSON.stringify(data) : null,\n        });\n        if (response.status === 200) {\n            return await response.json();\n        }\n        else {\n            let details: any;\n            try {\n                details = await response.json();\n            }\n            catch {}\n            throw new ServerError(response.status, response.statusText, details);\n        }\n    }\n    \n    private getFullUrl(url: string): string {\n        if (url.startsWith(\"/\")) {\n            url = url.substring(1);\n        }\n        return this.baseUrl + url;\n    }\n    \n    async executeBatch(): Promise<void> {\n        if (this.currentBatchedRequestsEx.length === 0) {\n            return;\n        }\n        \n        const batchedRequestsEx = this.currentBatchedRequestsEx;\n        this.currentBatchedRequestsEx = [];\n        const batchedRequestsExResolved: BatchedRequestEx[] = [];\n        for (const batchedRequestEx of batchedRequestsEx) {\n            if (batchedRequestEx instanceof Deferred) {\n                const req = await batchedRequestEx.getPromise();\n                if (req !== null) {\n                    batchedRequestsExResolved.push(req);\n                }\n            }\n            else {\n                batchedRequestsExResolved.push(batchedRequestEx);\n            }\n        }\n        const batchedRequests = batchedRequestsExResolved.map(request => (<Types.api.batch.BatchedRequest>{\n            method: request.method,\n            url: request.url,\n            data: request.data,\n        }));\n        \n        const data: Types.api.batch.Request = {\n            batchedRequests,\n        };\n        const result = await this.requestCore(\"post\", \"batch\", data) as Types.api.batch.Response;\n        for (let i = 0; i < batchedRequests.length; ++i) {\n            try {\n                const request = batchedRequestsExResolved[i]!;\n                const response = result.batchedResponses[i]!;\n                if (response.statusCode === 200) {\n                    request.deferred.resolve(JSON.parse(response.response));\n                }\n                else {\n                    let details: any;\n                    try {\n                        details = JSON.parse(response.response);\n                    }\n                    catch {}\n                    request.deferred.reject(new ServerError(response.statusCode, response.statusText, details));\n                }\n            }\n            catch (err) {\n                console.error(err);\n            }\n        }\n    }\n    \n    async buildRequestAsynchronously<T>(builder: () => Promise<() => Promise<T>>): Promise<T> {\n        if (!this.options.batchMode) {\n            return (await builder())();\n        }\n        const deferred = new Deferred<BatchedRequestEx | null>();\n        this.currentBatchedRequestsEx.push(deferred);\n        try {\n            const requestScheduler = await builder();\n            const requestPromise = requestScheduler();\n            const idx = this.currentBatchedRequestsEx.findIndex(req => req && !(req instanceof Deferred) && req.deferred.getPromise() === requestPromise);\n            if (idx < 0) {\n                throw new Error(\"buildRequestAsynchronously: no batched request\");\n            }\n            const batchedRequest = this.currentBatchedRequestsEx[idx];\n            if (!batchedRequest || batchedRequest instanceof Deferred) {\n                throw new Error(\"buildRequestAsynchronously: unexpected batched request object\");\n            }\n            this.currentBatchedRequestsEx.splice(idx, 1);\n            deferred.resolve(batchedRequest);\n            return requestPromise;\n        }\n        catch (err) {\n            deferred.resolve(null);\n            throw err;\n        }\n    }\n    \n    getCurrentBatchSize(): number {\n        return this.currentBatchedRequestsEx.length;\n    }\n    \n}\n","export class InvalidParamError extends Error {\n    \n    constructor(paramName: string) {\n        super(`Invalid param: ${paramName}`);\n    }\n    \n}\n","export class ServerError extends Error {\n    \n    static getErrorMessage(statusCode: number, statusText: string, details: any): string {\n        let msg = `Server error: ${statusCode} ${statusText}`;\n        if (details) {\n            msg += \" (\";\n            if (typeof(details) === \"object\") {\n                msg += JSON.stringify(details);\n            }\n            else {\n                msg += details;\n            }\n            msg += \")\";\n        }\n        return msg;\n    }\n    \n    constructor(protected statusCode: number, protected statusText: string, protected details: any) {\n        super(ServerError.getErrorMessage(statusCode, statusText, details));\n    }\n    \n    getStatusCode(): number {\n        return this.statusCode;\n    }\n    \n    getStatusMessage(): string {\n        return this.statusText;\n    }\n    \n    getDetails(): any {\n        return this.details;\n    }\n    \n}\n","export * from \"./InvalidParamError\";\nexport * from \"./ServerError\";\n","export * as errors from \"./errors\";\nexport * as specificApis from \"./specificApis\";\nexport * as utils from \"./utils\";\nexport * from \"./Api\";\nexport * from \"./Encryption\";\nexport * from \"./GenericApi\";\n","import * as Types from \"@wpazderski/kvapi-types\";\nimport { GenericApi } from \"../GenericApi\";\n\nexport class AppInfoApi {\n    \n    constructor(private genericApi: GenericApi) {\n    }\n    \n    async get(): Promise<Types.api.appInfo.GetAppInfoResponse> {\n        const response: Types.api.appInfo.GetAppInfoResponse = await this.genericApi.get(\"app-info\");\n        return response;\n    }\n    \n}\n","import * as Types from \"@wpazderski/kvapi-types\";\nimport { InvalidParamError } from \"../errors\";\nimport { GenericApi } from \"../GenericApi\";\n\nexport class EntriesApi {\n    \n    constructor(private genericApi: GenericApi, private entryAccess: Types.data.entry.EntryAccess) {\n    }\n    \n    async getAll(): Promise<Types.data.entry.KeyValueMap> {\n        const response: Types.api.entries.GetEntriesResponse = await this.genericApi.get(`${this.entryAccess}-entries`);\n        const entries: Types.data.entry.KeyValueMap = {};\n        for (const key in response.entries) {\n            let value = (response.entries as any)[key];\n            value = await this.genericApi.maybeDecrypt(value, this.entryAccess);\n            (entries as any)[key] = value;\n        }\n        return entries;\n    }\n    \n    async get(key: Types.data.entry.Key): Promise<Types.data.entry.Value> {\n        key = key.trim() as Types.data.entry.Key;\n        if (!key) {\n            throw new InvalidParamError(\"key\");\n        }\n        const response: Types.api.entries.GetEntryResponse = await this.genericApi.get(`${this.entryAccess}-entries/${key}`);\n        return this.genericApi.maybeDecrypt(response.value, this.entryAccess);\n    }\n    \n    async set(key: Types.data.entry.Key, value: Types.data.entry.Value): Promise<void> {\n        key = key.trim() as Types.data.entry.Key;\n        if (!key) {\n            throw new InvalidParamError(\"key\");\n        }\n        await this.genericApi.buildRequestAsynchronously(async () => {\n            value = await this.genericApi.maybeEncrypt(value, this.entryAccess);\n            const request: Types.api.entries.CreateOrUpdateEntryRequest = { value };\n            return () => this.genericApi.put(`${this.entryAccess}-entries/${key}`, request);\n        });\n    }\n    \n    async delete(key: Types.data.entry.Key): Promise<void> {\n        key = key.trim() as Types.data.entry.Key;\n        if (!key) {\n            throw new InvalidParamError(\"key\");\n        }\n        await this.genericApi.delete(`${this.entryAccess}-entries/${key}`, {});\n    }\n    \n}\n","import * as Types from \"@wpazderski/kvapi-types\";\nimport { Encryption } from \"../Encryption\";\nimport { GenericApi } from \"../GenericApi\";\n\nexport interface SessionApiOptions {\n    onSessionStarted: (response: Types.api.sessions.CreateSessionResponse, userPassword: Types.data.user.PlainPassword) => Promise<void>;\n    onSessionTerminated: () => Promise<void>;\n}\n\nexport class SessionsApi {\n    \n    constructor(private genericApi: GenericApi, private options: SessionApiOptions) {\n    }\n    \n    async create(userLogin: Types.data.user.Login, userPassword: Types.data.user.PlainPassword): Promise<Types.api.sessions.CreateSessionResponse> {\n        userPassword = await Encryption.sha512(userPassword);\n        const request: Types.api.sessions.CreateSessionRequest = { userLogin, userPassword };\n        const response: Types.api.sessions.CreateSessionResponse = await this.genericApi.post(\"sessions\", request, false);\n        if (response && response.id) {\n            await this.options.onSessionStarted(response, userPassword);\n        }\n        return response;\n    }\n    \n    async update(): Promise<void> {\n        await this.genericApi.patch<Types.api.sessions.UpdateSessionRequest, Types.api.sessions.UpdateSessionResponse>(\"sessions\", {}, false);\n    }\n    \n    async delete(): Promise<void> {\n        await this.genericApi.delete<Types.api.sessions.DeleteSessionRequest, Types.api.sessions.DeleteSessionResponse>(\"sessions\", {}, false);\n        await this.options.onSessionTerminated();\n    }\n    \n}\n","import * as Types from \"@wpazderski/kvapi-types\";\nimport { Encryption } from \"../Encryption\";\nimport { InvalidParamError } from \"../errors\";\nimport { GenericApi } from \"../GenericApi\";\n\nexport interface UsersApiOptions {\n    onBeforeUserUpdated: (userId: Types.data.user.Id, request: Types.api.users.UpdateUserRequest) => Promise<void>;\n    onUserUpdated: (user: Types.data.user.UserPublic | Types.data.user.UserWithoutPassword) => Promise<void>;\n}\n\nexport class UsersApi {\n    \n    constructor(private genericApi: GenericApi, private options: UsersApiOptions) {\n    }\n    \n    async getAll(): Promise<Types.data.user.UsersPublic> {\n        const result: Types.api.users.GetUsersResponse = await this.genericApi.get(\"users\");\n        return result.users;\n    }\n    \n    async get(userId: Types.data.user.Id): Promise<Types.data.user.UserPublic | Types.data.user.UserWithoutPassword> {\n        userId = userId.trim() as Types.data.user.Id;\n        if (!userId) {\n            throw new InvalidParamError(\"userId\");\n        }\n        const result: Types.api.users.GetUserResponse = await this.genericApi.get(`users/${userId}`);\n        return result.user;\n    }\n    \n    async create(request: Types.api.users.CreateUserRequest): Promise<Types.data.user.UserPublic> {\n        request = {\n            login: request.login,\n            password: await Encryption.sha512(request.password),\n            role: request.role,\n        };\n        const result: Types.api.users.CreateUserResponse = await this.genericApi.post(\"users\", request);\n        return result.user;\n    }\n    \n    async update(userId: Types.data.user.Id, request: Types.api.users.UpdateUserRequest): Promise<Types.data.user.UserPublic | Types.data.user.UserWithoutPassword> {\n        userId = userId.trim() as Types.data.user.Id;\n        if (!userId) {\n            throw new InvalidParamError(\"userId\");\n        }\n        const result: Types.api.users.UpdateUserResponse = await this.genericApi.buildRequestAsynchronously(async () => {\n            request = { ...request };\n            await this.options.onBeforeUserUpdated(userId, request);\n            if (request.password) {\n                request.password = await Encryption.sha512(request.password);\n            }\n            return () => this.genericApi.patch(`users/${userId}`, request);\n        });\n        if (\"privateData\" in result.user) {\n            this.options.onUserUpdated({\n                id: userId,\n                login: result.user.login,\n                role: result.user.role,\n                lastPasswordUpdateTimestamp: result.user.lastPasswordUpdateTimestamp,\n                privateData: result.user.privateData,\n            });\n        }\n        else {\n            this.options.onUserUpdated({\n                id: userId,\n                login: result.user.login,\n                role: result.user.role,\n            });\n        }\n        return result.user;\n    }\n    \n    async delete(userId: Types.data.user.Id): Promise<void> {\n        userId = userId.trim() as Types.data.user.Id;\n        if (!userId) {\n            throw new InvalidParamError(\"userId\");\n        }\n        await this.genericApi.delete<Types.api.users.DeleteUserRequest, Types.api.users.DeleteUserResponse>(`users/${userId}`, {});\n    }\n    \n}\n","export * from \"./AppInfoApi\";\nexport * from \"./EntriesApi\";\nexport * from \"./SessionsApi\";\nexport * from \"./UsersApi\";\n","export class Deferred<T> {\n    \n    private promise: Promise<T>;\n    // @ts-ignore\n    resolve: (value: T) => void;\n    // @ts-ignore\n    reject: (reason: any) => void;\n    \n    constructor() {\n        this.promise = new Promise<T>((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n    }\n    \n    getPromise(): Promise<T> {\n        return this.promise;\n    }\n    \n}\n","export * from \"./Deferred\";\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(607);\n"],"names":["root","factory","exports","module","define","amd","self","Api","constructor","baseUrl","options","parentApi","_userSessionId","_user","_userPasswordBasedEncryption","this","_genericApi","GenericApi","commonHeadersProvider","headers","userSessionId","genericApi","_appInfoApi","AppInfoApi","_publicEntriesApi","EntriesApi","_privateEntriesApi","_sessionsApi","SessionsApi","onSessionStarted","response","userPassword","onSessionTerminated","_usersApi","UsersApi","onBeforeUserUpdated","async","userId","request","onUserUpdated","user","appInfo","publicEntries","privateEntries","sessions","users","sessionId","userPasswordBasedEncryption","createSessionResponse","id","isE2EEncrypted","passwordBasedKey","Encryption","generateKeyFromPassword","passwordBasedEncryption","encryptionKey","privateData","JSON","parse","decrypt","importKey","generateRandomKey","exportKey","privateDataStr","encrypt","stringify","update","maybeInitEncryption","disposeEncryption","password","newPassword","newPasswordBasedKey","oldPasswordBasedEncryption","newPasswordBasedEncryption","createBatchedApi","batchMode","executeBatch","key","static","text","arrBuf","crypto","subtle","digest","TextEncoder","encode","Uint8Array","map","x","toString","padStart","join","arr","String","fromCharCode","str","from","split","chr","charCodeAt","Uint16Array","arrBuff","uint8ArrayToString","btoa","uint8Array","atob","name","generateKey","length","passwordData","hash","data","encryptedData","encryptCore","decryptCore","iv","getRandomValues","stringToUint16Array","stringToUint8Array","uint16ArrayToString","encryptCore16","decryptCore16","parentGenericApi","currentBatchedRequestsEx","_encryption","e2ee","endsWith","encryption","entryAccess","shouldUseEncryption","Error","get","url","canBeBatched","undefined","post","patch","put","delete","method","deferred","Deferred","push","getPromise","requestCore","fetch","getFullUrl","toUpperCase","body","status","json","details","ServerError","statusText","startsWith","substring","batchedRequestsEx","batchedRequestsExResolved","batchedRequestEx","req","batchedRequests","result","i","batchedResponses","statusCode","resolve","reject","err","console","error","builder","requestPromise","idx","findIndex","batchedRequest","splice","getCurrentBatchSize","InvalidParamError","paramName","super","getErrorMessage","msg","getStatusCode","getStatusMessage","getDetails","entries","value","maybeDecrypt","trim","buildRequestAsynchronously","maybeEncrypt","userLogin","sha512","login","role","lastPasswordUpdateTimestamp","promise","Promise","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","call"],"sourceRoot":""}